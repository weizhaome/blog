title: 常见排序算法总结
author: weizhao
tags:
  - sorts
categories: []
date: 2019-04-16 15:16:00
---
# 常见排序算法总结
## 冒泡排序
### 基本思想：
> 比较序列中相邻两个数据的大小，如果两个数的排序方式和目标相反则调换两个数的位置。
### 代码实现(python)：
	def bubble_sort(mylist):
    	n = len(mylist)
    	for j in range(n-1):
        	for i in range(0,n-1-j):
            	count = 0
            	if mylist[i]>mylist[i+1]:
                	mylist[i], mylist[i+1]=mylist[i+1],mylist[i]
                	count+=1
         	if count == 0:
             	break
### 时间复杂度：
> 最好情况：正序有序，则只需要比较n次不需要交换位置，则时间复杂度为O(n)。  
> 最坏情况：逆序有序，则需要比较(n-1)+(n-2)+......+1，则时间复杂度为O(n*n)。  
> 平均情况：O(n*n)。
### 稳定性：
> 稳定性是指序列中两个相等的数在经过排序算法后两个数的位置是否会发生变化，因为冒泡排序当相邻两个数相等时不会交换他们的位置，所以冒泡算法是稳定的。
## 插入排序
### 基本思想：
> 序列中的数往前依次与其前面的数作比较寻找该数的合适位置，直至最后一个元素。
### 代码实现(python)
	def insertion_sort(mylist):
    	n = len(mylist)
        for i in range(1,n):
        	for j in range(i,0,-1):
            	if mylist[j]>mylist[j-1]:
                	mylist[j],mylist[j-1]=mylist[j-1],mylist[j]
                    else:
                    	break
 ### 时间复杂度：
> 最好情况：正序有序，比较n次不需要交换位置，时间复杂度为O(n)。  
> 最坏情况：逆序有序，比较n个元素需要跟前面的n-1个元素比较，时间复杂度为O(n^2)。  
> 平均情况：O(n^2)。
### 稳定性：
> 当两个元素比较时如果两个元素相等则不需要移动，所以插入排序是稳定的。 
## 选择排序
### 基本思想：
>每次从待排序的数据元素中直接选择最大或者最小的元素作为序列的第一个元素。
### 代码实现（Python）
    def selection_sort(mylist):
        n = len(mylist)
        for i in range(0,n-1):
            min = mylist[i]
            for j in range(1,n):
                if min > mylist[j]:
                   min = mylist[j]
            if min != mylist[i]:
                temp = min
                min = mylist[j]
                mylist[j]=min
### 时间复杂度：
> 最好情况：O(n^2)  
> 最坏情况：O(n^2)  
> 平均情况：O(n^2)  
### 稳定性：
> 不稳定
## 希尔排序
### 基本思想：
> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。  
### 过程示意图：
![shell_sort](/images/sort/shell's sort.jpg)
## 归并排序
### 基本思想：
> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并
### 示例：
> 归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。  
> 如　设有数列{6，202，100，301，38，8，1}  
> 初始状态：6,202,100,301,38,8,1  
> 第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；  
> 第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；  
> 第三次归并后：{1,6,8,38,100,202,301},比较次数：4；  
> 总的比较次数为：3+4+4=11；  
> 逆序数为14；  
### 小结：
> 归并排序的速度仅次于快速排序，且是一种稳定的排序算法。
## 快速排序
### 基本思想：
> 任意选取待排序数组中的一个数作为关键数，将待排序数组中比关键数小的数都位于关键数的左边，比关键数大的数都在关键数的右边。
### 排序演示：
> 假设一开始序列{xi}是：5，3，7，6，4，1，0，2，9，10，8。  
此时，选取关键数为序列的第一个元素：ref=5，i=1，j=11。  
从后往前找，第一个比5小的数是x8=2，因此序列为：2，3，7，6，4，1，0，5，9，10，8。  
此时i=1，j=8，从前往后找，第一个比5大的数是x3=7，因此序列为：2，3，5，6，4，1，0，7，9，10，8。  
此时，i=3，j=8，从第8位往前找，第一个比5小的数是x7=0，因此：2，3，0，6，4，1，5，7，9，10，8。  
此时，i=3，j=7，从第3位往后找，第一个比5大的数是x4=6，因此：2，3，0，5，4，1，6，7，9，10，8。  
此时，i=4，j=7，从第7位往前找，第一个比5小的数是x6=1，因此：2，3，0，1，4，5，6，7，9，10，8。  
此时，i=4，j=6，从第4位往后找，直到第6位才有比5大的数，这时，i=j=6，ref成为一条分界线，它之前的数都比它小，之后的数都比它大，对于前后两部分数，可以采用同样的方法来排序。
### 小结：
> 快速排序是一种不稳定的排序算法，最好情况下的时间复杂度为O(nlog^n),最坏情况下为：O(n^2),平均情况下为：O(nlog^n)。